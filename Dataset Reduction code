import pandas as pd
import tensorflow as tf
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.utils import to_categorical

# Load the dataset
df = pd.read_csv(r'C:\Users\Admin\Downloads\datasets\preprocessed_combined_dataset.csv')

# Define target and feature columns
target_column = 'label'
feature_columns = [
    'ipv4_src_addr_149.171.126.18', 'ipv4_src_addr_149.171.126.4', 
    'ipv4_dst_addr_127.0.0.1', 'ipv4_dst_addr_59.166.0.5', 'l7_proto', 
    'server_tcp_flags', 'num_pkts_up_to_128_bytes', 'icmp_ipv4_type', 
    'num_pkts_1024_to_1514_bytes', 'dst_to_src_second_bytes', 
    'ipv4_src_addr_59.166.0.4', 'in_pkts', 'ipv4_src_addr_59.166.0.3', 
    'ipv4_src_addr_59.166.0.7', 'ipv4_dst_addr_149.171.126.15', 'attack_DoS', 
    'l4_dst_port', 'tcp_win_max_out', 'ipv4_dst_addr_192.168.241.50', 
    'ipv4_dst_addr_149.171.126.9', 'l4_src_port', 'ipv4_dst_addr_224.0.0.5', 
    'ipv4_src_addr_59.166.0.6', 'ipv4_src_addr_10.40.85.1', 
    'ipv4_dst_addr_149.171.126.13', 'max_ttl', 'attack_Worms', 
    'ftp_command_ret_code', 'icmp_type', 'max_ip_pkt_len', 
    'attack_Generic', 'ipv4_dst_addr_59.166.0.2', 'ipv4_src_addr_149.171.126.8', 
    'num_pkts_256_to_512_bytes', 'shortest_flow_pkt', 'attack_Benign', 
    'flow_duration_milliseconds', 'client_tcp_flags', 'ipv4_dst_addr_175.45.176.3', 
    'src_to_dst_avg_throughput', 'ipv4_dst_addr_149.171.126.17', 
    'longest_flow_pkt', 'ipv4_src_addr_149.171.126.10', 'attack_Exploits', 
    'tcp_win_max_in', 'ipv4_dst_addr_149.171.126.5', 'ipv4_dst_addr_149.171.126.11', 
    'attack_Fuzzers', 'ipv4_dst_addr_59.166.0.1', 'out_bytes', 
    'ipv4_dst_addr_149.171.126.19', 'ipv4_dst_addr_59.166.0.0', 
    'src_to_dst_second_bytes', 'in_bytes', 'out_pkts', 'duration_out', 
    'retransmitted_out_pkts', 'ipv4_src_addr_149.171.126.0', 
    'tcp_flags', 'min_ttl', 'dns_query_id', 'ipv4_src_addr_59.166.0.1', 
    'ipv4_src_addr_10.40.85.10', 'num_pkts_512_to_1024_bytes', 
    'dns_ttl_answer', 'ipv4_src_addr_10.40.182.6', 'retransmitted_in_bytes', 
    'min_ip_pkt_len', 'protocol', 'retransmitted_out_bytes'
]

# Ensure all feature columns are in the DataFrame
missing_features = [col for col in feature_columns if col not in df.columns]
if missing_features:
    print(f"Warning: Missing features {missing_features}")

# Prepare the data
X = df[feature_columns].values
y = df[target_column].values

# Standardize features
scaler = StandardScaler()
X = scaler.fit_transform(X)

# Convert labels to categorical if necessary
y = to_categorical(y)

# Split the data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Build the neural network model
model = Sequential()
model.add(Dense(128, input_dim=X_train.shape[1], activation='relu'))
model.add(Dense(64, activation='relu'))
model.add(Dense(y_train.shape[1], activation='softmax'))  # Assuming multiple classes

# Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model
model.fit(X_train, y_train, epochs=10, batch_size=32, validation_split=0.1)

# Evaluate the model
loss, accuracy = model.evaluate(X_test, y_test)
print(f"Model Accuracy: {accuracy:.2f}")

# Save the trained model
model.save(r'C:\Users\Admin\Downloads\datasets\trained_model.h5')
print("Model saved successfully.")
